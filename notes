AAR0nSx

1.Struktur

/kamera-steuerung
│
├── main.js       # Hauptprozess (Steuert Electron, IPC)
├── preload.js    # Sichere Kommunikation Renderer ↔ Main
├── app/          # Deine eigentliche App
│   ├── index.html
│   ├── renderer.js  # JS für die Website (Browser-Seite)
│   └── styles.css   # optionales CSS
└── package.json  # Electron und Node Konfiguration

2. Prinzip

- Index zeigt Buttons und Steuerflächen
- renderer fängt klicks ab und sendet Nachrichten an main.js (vielleicht auch eher alles in einer Datei)
- main.js führt Befehle an der Kamera aus (mit HTTP needle)

Um auf Event zu reagieren z.B.:

// renderer.js
ipcRenderer.send('move-camera', { direction: 'left' });

// main.js
ipcMain.on('move-camera', (event, data) => {
  console.log('Kamera bewegen:', data.direction);
  // Hier dann Request an Kamera senden
});

3. Frontend index und renderer.js (bzw. main.js wenn ichs zusammenlege)

- einfaches UI (Buttons für links, rechts etc.)
- Dropdown für Belichtung?
- Slider für zoom oder stufenweise irwie idk
=> onEvent(Button gedrückt) -> Kamera bewegt sich

4. Backend main.js

- empfängt steuerbefehle (vom renderer?)
- sendet HTTP request am Kamera (über needle oder fetch)
- Fehlerbehandlung:
    - Kamera nicht erreichbar (Netzwerkfehler, falsche IP)
    - Kamera gibt Fehlercode zurück (404, 500)
    - Timeout
    =>prüfen ob Error oder Statuscode nicht 200 sind

    needle.get('http://kamera-ip/befehl', (error, response) => {
      if (error) {
        console.error('Netzwerkfehler:', error.message);
        return;
      }
      if (response.statusCode !== 200) {
        console.error('Kamera Fehler:', response.statusCode);
        return;
      }
      console.log('Erfolgreich:', response.body);
    });


    - Bei Error erneut versuchen?
    - Fehlermeldung im Frontend ausgeben

    IPC Fehler:
    - Kanalname falsch
    - falsche/fehlende Parameter

    ipcMain.on('move-camera', (event, data) => {
      if (!data || !data.direction) {
        console.error('Ungültige Kamerasteuerung:', data);
        return;
      }
      console.log('Bewege Kamera Richtung:', data.direction);
    });


    BrowserWindow Fehler:
    - index nicht gefunden

    mainWindow.loadFile('index.html').catch(err => {
      console.error('Fehler beim Laden von index.html:', err);
    });


Stabilität:
    - Buttons deaktivieren, während anfrage läuft
    - automatisch neuen Versuch nach 1-2 Sekunden




    ------------------------------------------------------------


 TODO

JS writing an dreading files:

 https://nodejs.org/en/learn/manipulating-files/writing-files-with-nodejs

 https://www.w3schools.com/xml/xml_parser.asp

 https://www.mediaevent.de/javascript/xml-mit-fetch.html




WB

OnepushWb ist wbmodeidx = 3
Bei druck auf One push trigger Knopf
{"wbmodeidx":"","crgain":"","cbgain":"","wbonepushtrigger":"[object Event]"}

Manual red und Manual Blue sind nur im manual mode verfügbar
manual ist wbmodeidx = 5
Slider gehen von 0 bis 128 (beide)


Tabs für Settingspage?
https://www.w3schools.com/howto/howto_js_tabs.asp

oder hier vlt
https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Implement_a_settings_page



----------------
// Speichern nach Fokusbewegung:
localStorage.setItem("lastFocusMode", value); // "0" oder "1"
localStorage.setItem("lastFocusValue", value); // z. B. 1234

// Beim Start:
const savedMode = localStorage.getItem("lastFocusMode");
const savedFocus = localStorage.getItem("lastFocusValue");

if (savedMode !== null) window.electronAPI.setFocus("focusautoidx", savedMode);
if (savedFocus !== null) window.electronAPI.setFocus("focuspositon", savedFocus);




In JavaScript, localStorage ist ein Speicher, in dem Daten im Browser des Benutzers gespeichert werden können, ohne
 dass sie beim Schließen des Browsers gelöscht werden. setItem() speichert Daten mit einem Schlüssel und Wert,
 während getItem() gespeicherte Daten anhand des Schlüssels abruft.

setItem():
Syntax: localStorage.setItem(key, value);
Funktion: Speichert einen Wert (das Argument value) unter einem bestimmten Schlüssel (das Argument key) im localStorage.
Wenn ein Schlüssel bereits existiert, wird der Wert aktualisiert.
Beispiel: localStorage.setItem("username", "MaxMustermann"); speichert den Wert "MaxMustermann" unter dem
Schlüssel "username".

getItem():
Syntax: localStorage.getItem(key);
Funktion: Ruft den Wert aus dem localStorage ab, der mit dem angegebenen Schlüssel (das Argument key) verknüpft ist.
Beispiel: let username = localStorage.getItem("username"); speichert den Wert, der unter dem Schlüssel
"username" gespeichert ist, in der Variable username.

Zusätzliche Informationen:
Datenspeicherung: localStorage speichert Daten als Key-Value-Paare (Schlüssel-Wert).
Datentyp: Sowohl Schlüssel als auch Werte sind Strings.
Domain: Die Daten im localStorage sind domain-spezifisch, d.h. Daten, die auf einer Seite gespeichert werden,
sind nur für diese Seite und Unterseiten der gleichen Domain zugänglich.
Löschen: removeItem() entfernt ein Element aus dem localStorage. clear() löscht alle Daten aus dem localStorage.
Session Storage: Es gibt auch sessionStorage, das Daten nur während der Sitzung des Benutzers
(d.h. bis der Browser geschlossen wird) speichert.




Daten die geladen/gespeichert werden müssen:
ids der DOM Elemente:

zoom-level
zoom-slider

focus-mode
focus-range

wb-mode
wb-manual-red
wb-manual-blue

picture-brightness
picture-saturation
picture-sharpness

exposure-mode
shutter
gain
gamma



in den presets wird nicht alles gesetzt, zum Beispiel exposure mode ist immer auf full auto bei jedem preset,
auch wenn man es bei der preset Aufnahme geändert hat


-> Preset Buttons (weiße Zahl in der mitte) und den Screenshot vom preset in den Button reinladen
Man sieht sofort welche schon belegt sind und mit was




renderer js DOM Content loaded Inhalt:


window.addEventListener("DOMContentLoaded", async() => {
    document.body.tabIndex = 0;
    document.body.focus();


    //Kamera UIs erzeugen
    const settings = await window.electronAPI.getSettings();
    const cameraIPs = settings.cameraIPs || [];

    const container = document.querySelector(".max-w-5xl");

    const template = document.getElementById("camera-template");

    cameraIPs.forEach((ip, index) => {
        const clone = template.content.cloneNode(true);
        const wrapper = clone.querySelector(".camera-ui");
        wrapper.dataset.ip = ip;
        wrapper.querySelector(".camera-label").innerText = `${index + 1} (${ip})`;

        container.appendChild(wrapper);

        // Jetzt initialisiere die Logik pro Kamera
        initCameraUI(wrapper, ip);
    });






    // Direkt beim Start initialen Zustand setzen
    window.electronAPI.getSettings().then(settings => {
        updateDarkModeClass(settings.darkMode);
    });

    // Live-Toggle beim Event
    window.electronAPI.onDarkModeUpdate((isDarkMode) => {
        console.log("DARK MODE EVENT EMPFANGEN:", isDarkMode);
        updateDarkModeClass(isDarkMode);
    });

    // Funktion zum Hinzufügen/Entfernen
    function updateDarkModeClass(enabled) {
        const root = document.documentElement; // <html>
        if (enabled) {
            root.classList.add("dark");
        } else {
            root.classList.remove("dark");
        }
    }






    //aktualisieren der Werte in DOM mit den Werten aus getCameraData
    window.electronAPI.getCameraData().then(data => {
        console.log("Kameradaten:", data);

        // Zoom Level anzeigen
        if (data.zoomposition) {
            currentZoomLevel = parseFloat(data.zoomposition);
            document.getElementById("zoom-level").innerText = `${currentZoomLevel.toFixed(1)}x`;
            document.getElementById("zoom-slider").value = currentZoomLevel.toFixed(1);
            console.log(document.getElementById("zoom-slider").value);
        }



        //Fokus - Wichtig: Fokus wird default bei jedem neuen connect auf die cam zurückgesetzt!
        //Fokus Mode aktualisieren
        //Ja du liest richtig: positon statt position.
        //Die Kamera cgi Skripte haben einen Schreibfehler und ich dachte ich habe einen Schlaganfall
        if(data.focusautoidx && data.focuspositon) {
            console.log('Der Wert von data.focusautoidx: ', data.focusautoidx);
            console.log(`Focus Mode als ${data.focusautoidx} ausgelesen.`);
            document.getElementById("focus-mode").value = "1";
            console.log(`Focus Mode manuell auf ${document.getElementById("focus-mode").value} gesetzt.`);


            console.log('Der Wert von data.focusposition: ', data.focuspositon);
            document.getElementById("focus-range").value = data.focuspositon;
            console.log(`Focus Range als ${data.focuspositon} ausgelesen.`);
        }

        //Fokusmode
        //Fokus Automatisch senden bei Auswahl
        const focusElements = [
            { id: "focus-mode", key: "focusautoidx" }
        ];


        focusElements.forEach(({ id, key }) => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener("change", () => {
                    const value = el.value;
                    console.log(`Sende ${key}: ${value}`);
                    window.electronAPI.setFocus(key, value)
                        .then(response => {
                            console.log("Antwort:", response.message);
                        })
                        .catch(err => {
                            console.error("Fehler:", err);
                        });
                });
            }
        });

        //Fokus Slider handling
        const focusMapping = [
            { id: "focus-range",  key: "focuspositon",   valueId: "value-focus-range"}
        ];

        focusMapping.forEach(({ id, key, valueId }) => {
            const el = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);

            //Wenn es eine id von dem Attribut in index gibt und
            //Wenn es eine valueId vom Attribut in index gibt und
            //Wenn der key in data (Ergebnisse aus getCameraData) existiert
            if (el && valueDisplay && data[key] !== undefined) {
                // Initialwert aus Kamera setzen
                el.value = data[key]; //Wert aktualisieren
                console.log(`Der Wert ${el.value} wird auf ${data[key]} initialisiert.`);
                valueDisplay.textContent = data[key]; //Anzeigetext aktualisieren
                console.log(`Der Text ${valueDisplay.textContent} wird auf ${data[key]} initialisiert.`);

                // Anzeige bei Bewegung sofort aktualisieren
                // Wert senden
                el.addEventListener("input", () => { //change -> input, für direktes Feedback
                    valueDisplay.textContent = el.value;
                    window.electronAPI.setFocus(key, el.value)
                        .then(response => {
                            console.log(`WB-Wert ${key} gesetzt:`, response.message);
                        })
                        .catch(err => {
                            console.error(`Fehler beim Setzen von ${key}:`, err);
                        });
                });
            }
        });





        //WB Mode aktualisieren
        if(data.wbmodeidx) {
            document.getElementById("wb-mode").value = data.wbmodeidx;
            console.log(`WB Mode auf ${data.wbmodeidx} initialisiert.`);
        }
        //mode setzen
        //mode Automatisch senden bei Auswahl
        const whitebalanceElements = [
            { id: "wb-mode", key: "wbmodeidx" },
        ];

        data.wbmodeidx === "3" ? console.log("true") : document.getElementById("onePushWBButton").disabled = true;

        whitebalanceElements.forEach(({ id, key }) => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener("change", () => {
                    const value = el.value;
                    console.log(`Sende ${key}: ${value}`);
                    //console.log(typeof document.getElementById("wb-mode").value); -> die values sind wohl strings...
                    if(document.getElementById("wb-mode").value === "3") { //frag also nach string
                        document.getElementById("onePushWBButton").disabled = false;
                        console.log("Button aktiv");
                    }else{
                        document.getElementById("onePushWBButton").disabled = true;
                        console.log("Button wurde disabled");
                    }


                    window.electronAPI.setWhiteBalance(key, value)
                        .then(response => {
                            console.log("Antwort:", response.message);
                        })
                        .catch(err => {
                            console.error("Fehler:", err);
                        });
                });
            }
        });

        //WB Slider handling
        const whitebalanceMapping = [
            { id: "wb-manual-red",  key: "crgain",      valueId: "value-manual-red"},
            { id: "wb-manual-blue", key: "cbgain",      valueId: "value-manual-blue"}
        ];

        whitebalanceMapping.forEach(({ id, key, valueId }) => {
            const el = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);

            //Wenn es eine id von dem Attribut in index gibt und
            //Wenn es eine valueId vom Attribut in index gibt und
            //Wenn der key in data (Ergebnisse aus getCameraData) existiert
            if (el && valueDisplay && data[key] !== undefined) {
                // Initialwert aus Kamera setzen
                el.value = data[key]; //Wert aktualisieren
                console.log(`Der Wert ${el.value} wird auf ${data[key]} initialisiert.`);
                valueDisplay.textContent = data[key]; //Anzeigetext aktualisieren
                console.log(`Der Text ${valueDisplay.textContent} wird auf ${data[key]} initialisiert.`);

                // Anzeige bei Bewegung sofort aktualisieren
                // Wert senden
                el.addEventListener("input", () => { //change -> input, für direktes Feedback
                    valueDisplay.textContent = el.value;
                    window.electronAPI.setWhiteBalance(key, el.value)
                        .then(response => {
                            console.log(`WB-Wert ${key} gesetzt:`, response.message);
                        })
                        .catch(err => {
                            console.error(`Fehler beim Setzen von ${key}:`, err);
                        });
                });
            }
        });





        //Picture
        // Picture-Werte (Slider initialisieren und anzeigen)
        const pictureMapping = [
            { id: "picture-brightness", key: "brightness", valueId: "value-brightness"},
            { id: "picture-saturation", key: "saturation", valueId: "value-saturation" },
            { id: "picture-sharpness", key: "sharpness", valueId: "value-sharpness" }
        ];

        pictureMapping.forEach(({ id, key, valueId }) => {
            const el = document.getElementById(id);
            const valueDisplay = document.getElementById(valueId);

            //Wenn es eine id von dem Attribut in index gibt und
            //Wenn es eine valueId vom Attribut in index gibt und
            //Wenn der key in data (Ergebnisse aus getCameraData) existiert
            if (el && valueDisplay && data[key] !== undefined) {
                // Initialwert aus Kamera setzen
                el.value = data[key];
                valueDisplay.textContent = data[key];

                // Anzeige bei Bewegung sofort aktualisieren
                // Wert bei Loslassen senden
                el.addEventListener("input", () => { //change -> input, für direktes Feedback
                    valueDisplay.textContent = el.value;
                    window.electronAPI.setPicture(key, el.value)
                        .then(response => {
                            console.log(`Bildwert ${key} gesetzt:`, response.message);
                        })
                        .catch(err => {
                            console.error(`Fehler beim Setzen von ${key}:`, err);
                        });
                });
            }
        });


        // Belichtungseinstellungen
        const mapping = {
            "exposure-mode": "exposuremodeindex",
            "shutter": "shuttermanualidx",
            "gain": "gainmanualidx",
            "gamma": "gammanameindex"
        };

        Object.entries(mapping).forEach(([elementId, dataKey]) => {
            const el = document.getElementById(elementId);
            if (el && data[dataKey] !== undefined) {
                el.value = data[dataKey];
            }
        });
    });


    // Exposure Automatisch senden bei Auswahl
    const exposureElements = [
        { id: "exposure-mode", key: "exposuremodeindex" },
        { id: "shutter", key: "shuttermanualidx" },
        { id: "gain", key: "gainmanualidx" },
        { id: "gamma", key: "gammanameindex" }
    ];


    exposureElements.forEach(({ id, key }) => {
        const el = document.getElementById(id);
        if (el) {
            el.addEventListener("change", () => {
                const value = el.value;
                console.log(`Sende ${key}: ${value}`);
                window.electronAPI.setExposure(key, value)
                    .then(response => {
                        console.log("Antwort:", response.message);
                    })
                    .catch(err => {
                        console.error("Fehler:", err);
                    });
            });
        }
    });


    //BUTTONS
    const buttons = document.querySelectorAll(".direction-button");

    buttons.forEach(button => {
        const direction = button.dataset.direction;

        button.addEventListener("mousedown", () => {
            window.electronAPI.moveCamera(direction);
            console.log("Kamera bewegt sich:", direction);
        });

        const stopMovement = () => {
            window.electronAPI.moveCamera("stop");
            console.log("Kamera gestoppt");
        };

        button.addEventListener("mouseup", stopMovement);
        button.addEventListener("mouseleave", stopMovement);
    });

    //KEYS
    document.addEventListener("keydown", (event) => {
        if (!event.repeat) {
            // ZOOM IN (+)
            if (event.code === "BracketRight") {
                if (!zoomInterval) {
                    zoomInterval = setInterval(() => {
                        moreZoom();
                        console.log("Zooming in...");
                    }, 0);
                }
                return;
            }

            // ZOOM OUT (-)
            if (event.code === "Slash") {
                if (!zoomInterval) {
                    zoomInterval = setInterval(() => {
                        lessZoom();
                        console.log("Zooming out...");
                    }, 0);
                }
                return;
            }

            pressedKeys.add(event.code);
            handleCombinedDirection();
        }
    });

    document.addEventListener("keyup", (event) => {
        // Zoom beenden
        if (
            event.code === "BracketRight" ||
            event.code === "Slash"
        ) {
            if (zoomInterval) {
                clearInterval(zoomInterval);
                zoomInterval = null;
                console.log("Zoom gestoppt");
            }
            return;
        }

        pressedKeys.delete(event.code);

        if (pressedKeys.size === 0) {
            if (stopTimeout) clearTimeout(stopTimeout);
            stopTimeout = setTimeout(() => {
                window.electronAPI.moveCamera("stop");
                lastDirection = null;
                console.log("Kamera gestoppt");
            }, 400);
        } else {
            handleCombinedDirection();
        }
    });

    function handleCombinedDirection() {
        const direction = getCombinedDirection(Array.from(pressedKeys));
        if (direction && direction !== lastDirection) {
            window.electronAPI.moveCamera(direction);
            lastDirection = direction;
            console.log("Bewege Kamera:", direction);
        }
    }

    function getCombinedDirection(codes) {
        const keys = new Set(codes);
        const up = keys.has("ArrowUp");
        const down = keys.has("ArrowDown");
        const left = keys.has("ArrowLeft");
        const right = keys.has("ArrowRight");

        if (up && left) return "up_left";
        if (up && right) return "up_right";
        if (down && left) return "down_left";
        if (down && right) return "down_right";
        if (up) return "up";
        if (down) return "down";
        if (left) return "left";
        if (right) return "right";
        return null;
    }
});

